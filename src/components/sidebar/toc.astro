---
import { i18n } from "@i18n/translation";
import I18nKey from "@i18n/i18nKey";
import WidgetLayout from "./widgetLayout.astro";
import { NAVBAR_HEIGHT } from "@constants/constants";


interface Props {
    class?: string;
    style?: string;
    depth?: number;
}

const { class: className, style, depth = 3 } = Astro.props;
---

<WidgetLayout name={i18n(I18nKey.tableOfContents)} id="toc-wrapper" class:list={[className, "toc-hide"]} style={style}>
    <div class="toc-scroll-container">
        <table-of-contents class="group" id="toc" data-depth={depth} data-navbar-height={NAVBAR_HEIGHT}>
            <!-- TOC内容将由JavaScript动态生成 -->
        </table-of-contents>
    </div>
</WidgetLayout>

<script>
import { widgetManager } from "@utils/widget";


class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;

    constructor() {
        super();
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: 0 }
        );
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    };

    fallback = () => {
        if (!this.sections.length) return;

        for (let i = 0; i < this.sections.length; i++) {
            let offsetTop = this.sections[i].getBoundingClientRect().top;
            let offsetBottom = this.sections[i].getBoundingClientRect().bottom;

            if (this.isInRange(offsetTop, 0, window.innerHeight)
                || this.isInRange(offsetBottom, 0, window.innerHeight)
                || (offsetTop < 0 && offsetBottom > window.innerHeight)) {
                this.markActiveHeading(i);
            }
            else if (offsetTop > window.innerHeight) break;
        }
    };

    toggleActiveHeading = () => {
        let i = this.active.length - 1;
        let min = this.active.length - 1, max = -1;
        while (i >= 0 && !this.active[i]) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        while (i >= 0 && this.active[i]) {
            this.tocEntries[i].classList.add(this.visibleClass);
            min = Math.min(min, i);
            max = Math.max(max, i);
            i--;
        }
        while (i >= 0) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        if (min > max) {
            this.activeIndicator?.setAttribute("style", `opacity: 0`);
        } else {
            let parentOffset = this.tocEl?.getBoundingClientRect().top || 0;
            let scrollOffset = this.tocEl?.scrollTop || 0;
            let top = this.tocEntries[min].getBoundingClientRect().top - parentOffset + scrollOffset;
            let bottom = this.tocEntries[max].getBoundingClientRect().bottom - parentOffset + scrollOffset;
            this.activeIndicator?.setAttribute("style", `top: ${top}px; height: ${bottom - top}px`);
        }
    };

    scrollToActiveHeading = () => {
        // If the TOC widget can accommodate both the topmost and bottommost items, scroll to the topmost item.
        // Otherwise, scroll to the bottommost one.

        if (this.anchorNavTarget || !this.tocEl) return;
        const activeHeading =
            document.querySelectorAll<HTMLDivElement>(`#toc .${this.visibleClass}`);
        if (!activeHeading.length) return;

        const topmost = activeHeading[0];
        const bottommost = activeHeading[activeHeading.length - 1];
        const tocHeight = this.tocEl.clientHeight;

        let top;
        if (bottommost.getBoundingClientRect().bottom -
            topmost.getBoundingClientRect().top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: "smooth",
        });
    };

    update = () => {
        requestAnimationFrame(() => {
            this.toggleActiveHeading();
            // requestAnimationFrame(() => {
            this.scrollToActiveHeading();
            // });
        });
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        entries.forEach((entry) => {
            const id = entry.target.children[0]?.getAttribute("id");
            const idx = id ? this.headingIdxMap.get(id) : undefined;
            if (idx != undefined)
                this.active[idx] = entry.isIntersecting;

            if (entry.isIntersecting && this.anchorNavTarget == entry.target.firstChild)
                this.anchorNavTarget = null;
        });

        if (!this.active.includes(true))
            this.fallback();
        this.update();
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement);

        if (anchor) {
            event.preventDefault(); // 阻止默认的锚点跳转
            const id = decodeURIComponent(anchor.hash?.substring(1));
            const targetElement = document.getElementById(id);
            if (targetElement) {
                // 计算目标位置，与移动端保持一致
                const navbarHeight = parseInt(this.dataset.navbarHeight || '88');
                const targetTop = targetElement.getBoundingClientRect().top + window.scrollY - navbarHeight;
                // 使用与移动端相同的滚动方式
                window.scrollTo({
                    top: targetTop,
                    behavior: "smooth"
                });
            }
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                this.anchorNavTarget = this.headings[idx];
            } else {
                this.anchorNavTarget = null;
            }
        }
    };

    isPostPage() {
        return window.location.pathname.includes('/posts/') ||
               document.querySelector('.custom-md, .markdown-content') !== null;
    }

    regenerateTOC(retryCount = 0) {
        const tocWidget = document.querySelector('widget-layout[data-id="toc-wrapper"]') as HTMLElement;
        if (!tocWidget) return;

        // 从当前页面重新获取标题
        const headings = widgetManager.getPageHeadings();
        // 如果没有标题，延迟重试最多3次
        if (headings.length === 0 && retryCount < 3) {
            setTimeout(() => this.regenerateTOC(retryCount + 1), 120);
            return;
        }

        const isPost = this.isPostPage();

        if (headings.length === 0 && !isPost) {
            if (!tocWidget.classList.contains('toc-hide')) {
                tocWidget.style.maxHeight = tocWidget.offsetHeight + 'px';
                tocWidget.offsetHeight; // force reflow
                tocWidget.classList.add('toc-hide');
                tocWidget.style.maxHeight = '';
            }
            return;
        }

        if (tocWidget.classList.contains('toc-hide')) {
            tocWidget.classList.remove('toc-hide');
            const targetHeight = tocWidget.scrollHeight;
            tocWidget.style.maxHeight = '0px';
            tocWidget.offsetHeight; // force reflow
            tocWidget.style.maxHeight = targetHeight + 'px';
            setTimeout(() => {
                if (!tocWidget.classList.contains('toc-hide')) {
                    tocWidget.style.maxHeight = '';
                }
            }, 300);
        }
        // 重新生成TOC HTML
        const minDepth = Math.min(...headings.map(h => h.depth));
        const maxLevel = parseInt(this.dataset.depth || '3'); 
        let heading1Count = 1;
        const tocHTML = headings
            .filter(heading => heading.depth < minDepth + maxLevel)
            .map(heading => {
                const depthClass = heading.depth === minDepth ? '' :
                    heading.depth === minDepth + 1 ? 'ml-4' : 'ml-8';
                const badgeContent = heading.depth === minDepth ? (heading1Count++) :
                    heading.depth === minDepth + 1 ? '<div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>' :
                    '<div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>';
                return `<a href="#${heading.slug}" class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2">
                    <div class="transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold ${depthClass} ${heading.depth === minDepth ? 'bg-[var(--toc-badge-bg)] text-[var(--btn-content)]' : ''}">
                        ${badgeContent}
                    </div>
                    <div class="transition text-sm ${heading.depth <= minDepth + 1 ? 'text-50' : 'text-30'}">${heading.text}</div>
                </a>`;
            }).join('');
        this.innerHTML = tocHTML + '<div id="active-indicator" style="opacity: 0" class="-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"></div>';
    }

    init() {
        // 先清理之前的监听器
        this.observer.disconnect();
        this.headingIdxMap.clear();

        // 重新生成TOC内容
        this.regenerateTOC();

        this.tocEl = this.parentElement;

        this.tocEl?.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });

        this.activeIndicator = document.getElementById("active-indicator");

        this.tocEntries = Array.from(
            this.querySelectorAll<HTMLAnchorElement>("a[href^='#']")
        );

        if (this.tocEntries.length === 0) return;

        this.sections = new Array(this.tocEntries.length);
        this.headings = new Array(this.tocEntries.length);
        for (let i = 0; i < this.tocEntries.length; i++) {
            const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
            const heading = document.getElementById(id);
            const section = heading?.parentElement;
            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(id, i);
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        this.sections.forEach((section) =>
            this.observer.observe(section)
        );

        this.fallback();
        this.update();
    };

    connectedCallback() {
        // 优先监听动画结束，兜底定时初始化，确保二次刷新也能正常显示 TOC
        const element = document.querySelector('.custom-md') || document.querySelector('.prose') || document.querySelector('.markdown-content');
        let initialized = false;
        const tryInit = () => {
            if (!initialized) {
                initialized = true;
                this.init();
            }
        };
        if (element) {
            element.addEventListener('animationend', tryInit, { once: true });
            // 兜底：无论动画是否触发，300ms后强制初始化一次
            setTimeout(tryInit, 300);
        } else {
            // 没有动画元素，直接初始化，兜底再延迟一次
            tryInit();
            setTimeout(tryInit, 300);
        }

        // 监听 Swup 页面过渡，确保 TOC 与内容同步消失
        const setupSwup = () => {
            if (window.swup && window.swup.hooks) {
                // 避免重复添加监听器
                if ((this as any)._swupListenersAdded) return;

                window.swup.hooks.on('visit:start', () => {
                    // 检查当前是否在文章页面
                    if (this.isPostPage()) {
                        const tocWidget = document.querySelector('widget-layout[data-id="toc-wrapper"]') as HTMLElement;
                        if (tocWidget && !tocWidget.classList.contains('toc-hide')) {
                            tocWidget.style.maxHeight = tocWidget.offsetHeight + 'px';
                            tocWidget.offsetHeight; // force reflow
                            tocWidget.classList.add('toc-hide');
                            tocWidget.style.maxHeight = '';
                        }
                    }
                });

                window.swup.hooks.on('content:replace', () => {
                    const tocWidget = document.querySelector('widget-layout[data-id="toc-wrapper"]') as HTMLElement;
                    if (tocWidget) {
                        // 检查新页面是否可能是文章页
                        if (!this.isPostPage()) {
                            tocWidget.classList.add('toc-hide');
                            tocWidget.style.maxHeight = '';
                        }
                    }
                    // 重新初始化 TOC
                    setTimeout(() => this.init(), 100);
                });

                (this as any)._swupListenersAdded = true;
            }
        };

        if (window.swup) {
            setupSwup();
        } else {
            document.addEventListener('swup:enable', setupSwup);
        }

        // 监听内容解密事件
        window.addEventListener('content-decrypted', () => {
            this.init();
        });
    };

    disconnectedCallback() {
        this.sections.forEach((section) =>
            this.observer.unobserve(section)
        );
        this.observer.disconnect();
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>

<style>
    .toc-scroll-container {
        max-height: calc(100vh - 20rem);
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
    }
    .toc-scroll-container::-webkit-scrollbar {
        width: 4px;
    }
    .toc-scroll-container::-webkit-scrollbar-track {
        background: transparent;
    }
    .toc-scroll-container::-webkit-scrollbar-thumb {
        background: var(--toc-btn-hover);
        border-radius: 10px;
    }
    table-of-contents#toc {
        position: relative;
        display: block;
    }

    /* 基础过渡样式 */
    :global(widget-layout[data-id="toc-wrapper"]) {
        transition: 
            max-height 300ms cubic-bezier(0.4, 0, 0.2, 1),
            opacity 300ms cubic-bezier(0.4, 0, 0.2, 1),
            margin-bottom 300ms cubic-bezier(0.4, 0, 0.2, 1),
            padding 300ms cubic-bezier(0.4, 0, 0.2, 1),
            visibility 300ms;
        max-height: 1200px; /* 足够容纳目录的高度，避免 100vh 可能带来的过长过渡延迟 */
        overflow: hidden;
        display: block; /* 覆盖之前可能的 grid 设置 */
    }
    /* 隐藏状态 */
    :global(widget-layout[data-id="toc-wrapper"].toc-hide) {
        max-height: 0;
        opacity: 0;
        margin-bottom: -1rem; /* 抵消父级 flex 的 gap-4 */
        padding-top: 0 !important;
        padding-bottom: 0 !important;
        visibility: hidden;
        pointer-events: none;
    }
</style>